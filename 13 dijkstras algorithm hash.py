# Алгоритм Дейкстры, используя хеш-таблицу (словарь).
# Здесь нам нужно найти все кратчайшие пути от начального узла до всех остальных узлов
# в направленном ациклическом взвешенном графе.
# ----------
# Dijkstra's algorithm using hash table (dictionary).
#


# Создаем словарь "graph", который представляет из себя направленный ациклический взвешенный граф.
# Особенность этого графа в том, что c каждым ключом связано значение, которое является словарем.
# Эти словари представляют из себя список соседних узлов каждого узла этого графа.
# ----------
#
graph = {"start": {"a": 6,
                   "b": 2},
         "a": {"fin": 1},
         "b": {"a": 3,
               "fin": 5},
         "fin": {}}


# Создаем переменную "infinity", которая хранит "бесконечность". Мы будем использовать эту переменную,
# когда неизвестен путь до какого-либо узла.
# ----------
#
infinity = float("inf")


# Создаем словарь "costs", который представляет из себя таблицу стоимостей
# путей от узла "start" до других узлов графа "graph".
# Указываем те стоимоисти, которые известны в начале работы алгоритма.
# В комментариях ниже указаны изменения значений после работы каждого цикла while,
# который находится внизу этой программы.
# ----------
#
costs = {"a": 6,            # 5 - 5 - 5
         "b": 2,            # 2 - 2 - 2
         "fin": infinity}   # 7 - 6 - 6


# Создаем словарь "parents", который представляет из себя таблицу родителей узлов в графе "graph".
# Указываем тех родителей, которые известны в начале работы алгоритма.
# В комментариях ниже указаны изменения значений после работы каждого цикла while,
# который находится внизу этой программы.
# ----------
#
parents = {"a": "start",    # "b"     - "b"     - "b"
           "b": "start",    # "start" - "start" - "start"
           "fin": None}     # "b"     - "a"     - "a"


# Создаем список "processed", в который мы добавляем уже обработанные узлы,
# чтобы избежать повторной обработки таких узлов.
# ----------
#
processed = []


# Создаем функцию "find_lowest_cost_node", которая принимает один входной параметр:
# словарь "table_of_costs", который представляет из себя таблицу стоимостей
# путей от начального узла до других узлов направленного ациклическего взвешенного графа.
# Эта функция возвращает имя узла с наименьшей стоимостью.
# ----------
#
def find_lowest_cost_node(table_of_costs):
    # Создаем переменную "lowest_cost", которая хранит стоимость узла, который имеет наименьшую стоимость.
    # Изначально эта переменная хранит значение "бесконечность".
    # ----------
    #
    lowest_cost = float("inf")
    # Создаем переменную "lowest_cost_node", которая хранит узел, который имеет наименьшую стоимость.
    # Изначально эта переменная хранит значение "None".
    # ----------
    #
    lowest_cost_node = None
    # Создаем цикл for, в котором перебираем все ключи (узлы графа) словаря "table_of_costs".
    # ----------
    #
    for key_node in table_of_costs:
        # Создаем переменную "value_cost", которая хранит значение (стоимость узла графа)
        # по текущему ключу (узлу графа).
        # ----------
        #
        value_cost = table_of_costs[key_node]
        # Если стоимость текущего узла графа меньше стоимости узла, который имеет наименьшую стоимость,
        # и если мы еще не обрабатывали этот узел, то
        # ----------
        #
        if value_cost < lowest_cost and key_node not in processed:
            # считаем, что стоимость текущего узла графа является наименьшей,
            # ----------
            #
            lowest_cost = value_cost
            # а также считаем, что этот узел является узлом, который имеет наименьшую стоимость.
            # ----------
            #
            lowest_cost_node = key_node
    # В итоге работы этого цикла for функция "find_lowest_cost_node" возвращает имя узла с наименьшей стоимостью.
    # Ключевое слово "return" выходит из функции и возвращает какое-либо значение.
    # ----------
    #
    # The keyword "return" is to exit a function and return a value.
    return lowest_cost_node


# Находим имя узла с наименьшей стоимостью в словаре "costs" (изначально таким узлом является узел "b" со стоимостью 2).
# В комментариях ниже указаны изменения значений этой переменной после работы каждого цикла while,
# который находится внизу этой программы.
# ----------
#
node = find_lowest_cost_node(costs)  # "a" - "fin" - None


# Высчитываем все кратчайшие пути от узла "start" до узлов "a", "b" и "fin" путем обновления словаря "costs".
# Создаем цикл while, который работает пока переменная "node" не является пустой,
# то есть пока у нас есть узлы с наименьшей стоимостью для обработки.
# ----------
#
while node is not None:
    # Создаем переменную "cost", которая хранит стоимость текущего узла с наименьшей стоимостью "node".
    # ----------
    #
    cost = costs[node]
    # Создаем переменную "neighbors", которая хранит словарь, представляющий из себя
    # список соседних узлов текущего узла с наименьшей стоимостью "node" и их стоимости.
    # ----------
    #
    neighbors = graph[node]
    # Создаем цикл for, в котором перебираем
    # ключи (имена всех соседних узлов текущего узла с наименьшей стоимостью "node") в словаре "neighbors".
    # ----------
    #
    for neighbor_name in neighbors.keys():
        # Высчитываем новую стоимость пути от узла "start"
        # до текущего соседнего узла текущего узла с наименьшей стоимостью "node".
        # ----------
        #
        new_cost = cost + neighbors[neighbor_name]
        # Если текущая стоимость пути от узла "start"
        # до текущего соседнего узла текущего узла с наименьшей стоимостью "node"
        # больше, чем новая стоимость этого пути, то
        # ----------
        #
        if costs[neighbor_name] > new_cost:
            # обновляем текущую стоимость этого пути в словаре "costs",
            # ----------
            #
            costs[neighbor_name] = new_cost
            # а также обновляем родителя текущего соседнего узла текущего узла с наименьшей стоимостью "node"
            # в словаре "parents".
            # ----------
            #
            parents[neighbor_name] = node
    # Когда заканчивается перебор всех соседних узлов текущего узла с наименьшей стоимостью "node",
    # тогда добавляем этот узел с наименьшей стоимостью "node" в список "processed"
    # ----------
    #
    processed.append(node)
    # и находим следующий узел, который имеет наименьшую стоимость,
    # и работа этого цикла while продолжается с начала с этим узлом.
    node = find_lowest_cost_node(costs)


# Выводим на экран словарь "costs", содержащий стоимости
# всех кратчайших путей от узла "start" до остальных узлов графа "graph".
# Функция "print()" выводит некую указанную информацию на экран или на какое-либо другое устройство вывода.
# ----------
#
# The function "print()" prints the specified message to the screen, or other standard output device.
print(costs)
